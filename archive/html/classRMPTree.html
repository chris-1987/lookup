<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>iplookup: RMPTree&lt; W, K, U, MP, MC, V, H1, H2 &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">iplookup
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Simulation for IPv4/IPv6 Lookup in Random Pipeline</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classRMPTree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RMPTree&lt; W, K, U, MP, MC, V, H1, H2 &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Build and update the index.  
 <a href="classRMPTree.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="rmptree_8h_source.html">rmptree.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRMPTree_1_1SortElem.html">SortElem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">element to be sorted  <a href="structRMPTree_1_1SortElem.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa40e0de7051ee571a9d89cd9106e0c62"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMPTree.html#aa40e0de7051ee571a9d89cd9106e0c62">RMPTree</a> ()</td></tr>
<tr class="memdesc:aa40e0de7051ee571a9d89cd9106e0c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">default ctor  <a href="#aa40e0de7051ee571a9d89cd9106e0c62">More...</a><br/></td></tr>
<tr class="separator:aa40e0de7051ee571a9d89cd9106e0c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398eb082ee35f45e8e2e119478c3c7aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMPTree.html#a398eb082ee35f45e8e2e119478c3c7aa">initializeParameters</a> ()</td></tr>
<tr class="memdesc:a398eb082ee35f45e8e2e119478c3c7aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize parameters  <a href="#a398eb082ee35f45e8e2e119478c3c7aa">More...</a><br/></td></tr>
<tr class="separator:a398eb082ee35f45e8e2e119478c3c7aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c366d17bf6c7082188d45b0a9e967a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMPTree.html#a77c366d17bf6c7082188d45b0a9e967a">RMPTree</a> (const <a class="el" href="classRMPTree.html">RMPTree</a> &amp;_mpt)=delete</td></tr>
<tr class="memdesc:a77c366d17bf6c7082188d45b0a9e967a"><td class="mdescLeft">&#160;</td><td class="mdescRight">disable copy-ctor  <a href="#a77c366d17bf6c7082188d45b0a9e967a">More...</a><br/></td></tr>
<tr class="separator:a77c366d17bf6c7082188d45b0a9e967a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16ed3a2d18e52997dfaff4870f2372d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRMPTree.html">RMPTree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMPTree.html#ae16ed3a2d18e52997dfaff4870f2372d">operator=</a> (const <a class="el" href="classRMPTree.html">RMPTree</a> &amp;)=delete</td></tr>
<tr class="memdesc:ae16ed3a2d18e52997dfaff4870f2372d"><td class="mdescLeft">&#160;</td><td class="mdescRight">disable assignment op  <a href="#ae16ed3a2d18e52997dfaff4870f2372d">More...</a><br/></td></tr>
<tr class="separator:ae16ed3a2d18e52997dfaff4870f2372d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23a18d501f8c430a9c313e5a11f5017"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMPTree.html#ac23a18d501f8c430a9c313e5a11f5017">~RMPTree</a> ()</td></tr>
<tr class="memdesc:ac23a18d501f8c430a9c313e5a11f5017"><td class="mdescLeft">&#160;</td><td class="mdescRight">dtor  <a href="#ac23a18d501f8c430a9c313e5a11f5017">More...</a><br/></td></tr>
<tr class="separator:ac23a18d501f8c430a9c313e5a11f5017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc7500f870bdf78aee90553dff1fb83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMPTree.html#acdc7500f870bdf78aee90553dff1fb83">clear</a> ()</td></tr>
<tr class="memdesc:acdc7500f870bdf78aee90553dff1fb83"><td class="mdescLeft">&#160;</td><td class="mdescRight">clear  <a href="#acdc7500f870bdf78aee90553dff1fb83">More...</a><br/></td></tr>
<tr class="separator:acdc7500f870bdf78aee90553dff1fb83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a178a47b5eb15869548e79cc13dee8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMPTree.html#a2a178a47b5eb15869548e79cc13dee8f">build</a> (const std::string &amp;_fn)</td></tr>
<tr class="memdesc:a2a178a47b5eb15869548e79cc13dee8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the index.  <a href="#a2a178a47b5eb15869548e79cc13dee8f">More...</a><br/></td></tr>
<tr class="separator:a2a178a47b5eb15869548e79cc13dee8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59486bc75a65d7ee31e1d54cd64162e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMPTree.html#ac59486bc75a65d7ee31e1d54cd64162e">destroy</a> (size_t _idx)</td></tr>
<tr class="memdesc:ac59486bc75a65d7ee31e1d54cd64162e"><td class="mdescLeft">&#160;</td><td class="mdescRight">destroy a multi-prefix tree  <a href="#ac59486bc75a65d7ee31e1d54cd64162e">More...</a><br/></td></tr>
<tr class="separator:ac59486bc75a65d7ee31e1d54cd64162e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740480779eca4924a14f512af6e70675"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMPTree.html#a740480779eca4924a14f512af6e70675">report</a> ()</td></tr>
<tr class="memdesc:a740480779eca4924a14f512af6e70675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report the collected information.  <a href="#a740480779eca4924a14f512af6e70675">More...</a><br/></td></tr>
<tr class="separator:a740480779eca4924a14f512af6e70675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c8ca5d99c9fce9aeeddae0a2479bb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMPTree.html#a97c8ca5d99c9fce9aeeddae0a2479bb2">ins</a> (const <a class="el" href="classRMPTree.html#a3dc76d54f334071d8a2bac2422db0159">ip_type</a> &amp;_prefix, const <a class="el" href="types_8h.html#a34ecedcf03a70dc91e4616212d79267d">uint8</a> &amp;_length, const <a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a> &amp;_nexthop)</td></tr>
<tr class="memdesc:a97c8ca5d99c9fce9aeeddae0a2479bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a prefix into the index.  <a href="#a97c8ca5d99c9fce9aeeddae0a2479bb2">More...</a><br/></td></tr>
<tr class="separator:a97c8ca5d99c9fce9aeeddae0a2479bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02e80665c49225e72e76fd4867e2c30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMPTree.html#ac02e80665c49225e72e76fd4867e2c30">ins</a> (const <a class="el" href="classRMPTree.html#a3dc76d54f334071d8a2bac2422db0159">ip_type</a> &amp;_prefix, const <a class="el" href="types_8h.html#a34ecedcf03a70dc91e4616212d79267d">uint8</a> &amp;_length, const <a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a> &amp;_nexthop, <a class="el" href="classRMPTree.html#ac37da419a61106e5996632fc83670959">pnode_type</a> *&amp;_pnode, const int _level, const <a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a> _treeIdx)</td></tr>
<tr class="memdesc:ac02e80665c49225e72e76fd4867e2c30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a prefix into the MPT forest.  <a href="#ac02e80665c49225e72e76fd4867e2c30">More...</a><br/></td></tr>
<tr class="separator:ac02e80665c49225e72e76fd4867e2c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ae5c5ba559386a2e318ad1f9d76832"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMPTree.html#a36ae5c5ba559386a2e318ad1f9d76832">insertPrefixInPNode</a> (<a class="el" href="classRMPTree.html#ac37da419a61106e5996632fc83670959">pnode_type</a> *_pnode, const <a class="el" href="classRMPTree.html#a3dc76d54f334071d8a2bac2422db0159">ip_type</a> &amp;_prefix, const <a class="el" href="types_8h.html#a34ecedcf03a70dc91e4616212d79267d">uint8</a> &amp;_length, const <a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a> &amp;_nexthop)</td></tr>
<tr class="memdesc:a36ae5c5ba559386a2e318ad1f9d76832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert prefix into a non-full pnode.  <a href="#a36ae5c5ba559386a2e318ad1f9d76832">More...</a><br/></td></tr>
<tr class="separator:a36ae5c5ba559386a2e318ad1f9d76832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf994ca8e073378dc4a643b1d9c1cfc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMPTree.html#abf994ca8e073378dc4a643b1d9c1cfc7">deletePrefixInPNode</a> (<a class="el" href="structPNode.html">PNode</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K &gt; *_pnode, const int _pos)</td></tr>
<tr class="memdesc:abf994ca8e073378dc4a643b1d9c1cfc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">delete a prefix at certain position from a primary node  <a href="#abf994ca8e073378dc4a643b1d9c1cfc7">More...</a><br/></td></tr>
<tr class="separator:abf994ca8e073378dc4a643b1d9c1cfc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26712b559e84c21ee0f3d03ee89bf6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMPTree.html#af26712b559e84c21ee0f3d03ee89bf6b">ins</a> (const <a class="el" href="classRMPTree.html#a3dc76d54f334071d8a2bac2422db0159">ip_type</a> &amp;_prefix, const <a class="el" href="types_8h.html#a34ecedcf03a70dc91e4616212d79267d">uint8</a> &amp;_length, const <a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a> &amp;_nexthop, <a class="el" href="classRMPTree.html#ade23f0b765f589613fe10d6cbab738e2">snode_type</a> *&amp;_snode, const int _sLevel, const int _pLevel, const <a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a> _treeIdx)</td></tr>
<tr class="memdesc:af26712b559e84c21ee0f3d03ee89bf6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a prefix into the auxiliary tree.  <a href="#af26712b559e84c21ee0f3d03ee89bf6b">More...</a><br/></td></tr>
<tr class="separator:af26712b559e84c21ee0f3d03ee89bf6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba048ea59e12faeac571ef5895feb55d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMPTree.html#aba048ea59e12faeac571ef5895feb55d">search</a> (const <a class="el" href="classRMPTree.html#a3dc76d54f334071d8a2bac2422db0159">ip_type</a> &amp;_ip, std::vector&lt; int &gt; &amp;_trace)</td></tr>
<tr class="memdesc:aba048ea59e12faeac571ef5895feb55d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search LPM for the input IP address.  <a href="#aba048ea59e12faeac571ef5895feb55d">More...</a><br/></td></tr>
<tr class="separator:aba048ea59e12faeac571ef5895feb55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb968111f77661b1e7dc46b2d00bb947"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMPTree.html#aeb968111f77661b1e7dc46b2d00bb947">generateTrace</a> (const std::string &amp;_reqFile, const std::string &amp;_traceFile)</td></tr>
<tr class="memdesc:aeb968111f77661b1e7dc46b2d00bb947"><td class="mdescLeft">&#160;</td><td class="mdescRight">generate lookup trace for simulation  <a href="#aeb968111f77661b1e7dc46b2d00bb947">More...</a><br/></td></tr>
<tr class="separator:aeb968111f77661b1e7dc46b2d00bb947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48e9bf6f019b2ae704f61a885c96cd7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMPTree.html#ad48e9bf6f019b2ae704f61a885c96cd7">del</a> (const <a class="el" href="classRMPTree.html#a3dc76d54f334071d8a2bac2422db0159">ip_type</a> &amp;_prefix, const <a class="el" href="types_8h.html#a34ecedcf03a70dc91e4616212d79267d">uint8</a> &amp;_length)</td></tr>
<tr class="memdesc:ad48e9bf6f019b2ae704f61a885c96cd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a prefix from the index.  <a href="#ad48e9bf6f019b2ae704f61a885c96cd7">More...</a><br/></td></tr>
<tr class="separator:ad48e9bf6f019b2ae704f61a885c96cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b15911964ac9d5312248c5c13f33077"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMPTree.html#a4b15911964ac9d5312248c5c13f33077">del</a> (const <a class="el" href="classRMPTree.html#a3dc76d54f334071d8a2bac2422db0159">ip_type</a> &amp;_prefix, const <a class="el" href="types_8h.html#a34ecedcf03a70dc91e4616212d79267d">uint8</a> &amp;_length, <a class="el" href="structPNode.html">PNode</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K &gt; *&amp;_pnode, const int _level, <a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a> _treeIdx)</td></tr>
<tr class="memdesc:a4b15911964ac9d5312248c5c13f33077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a prefix in the index.  <a href="#a4b15911964ac9d5312248c5c13f33077">More...</a><br/></td></tr>
<tr class="separator:a4b15911964ac9d5312248c5c13f33077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b3605159043ab336af2f31c218cf9c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMPTree.html#a49b3605159043ab336af2f31c218cf9c">findPrefixInPNode</a> (<a class="el" href="classRMPTree.html#ac37da419a61106e5996632fc83670959">pnode_type</a> *_pnode, const <a class="el" href="classRMPTree.html#a3dc76d54f334071d8a2bac2422db0159">ip_type</a> &amp;_prefix, const <a class="el" href="types_8h.html#a34ecedcf03a70dc91e4616212d79267d">uint8</a> &amp;_length)</td></tr>
<tr class="memdesc:a49b3605159043ab336af2f31c218cf9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to find a prefix in a primary node.  <a href="#a49b3605159043ab336af2f31c218cf9c">More...</a><br/></td></tr>
<tr class="separator:a49b3605159043ab336af2f31c218cf9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae74702ea82f7bb98eba8ce5cb1ccc98c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMPTree.html#ae74702ea82f7bb98eba8ce5cb1ccc98c">del</a> (const <a class="el" href="classRMPTree.html#a3dc76d54f334071d8a2bac2422db0159">ip_type</a> &amp;_prefix, const <a class="el" href="types_8h.html#a34ecedcf03a70dc91e4616212d79267d">uint8</a> &amp;_length, <a class="el" href="classRMPTree.html#ade23f0b765f589613fe10d6cbab738e2">snode_type</a> *&amp;_snode, const int _sLevel, const int _pLevel, const <a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a> _treeIdx)</td></tr>
<tr class="memdesc:ae74702ea82f7bb98eba8ce5cb1ccc98c"><td class="mdescLeft">&#160;</td><td class="mdescRight">delete a prefix in an auxiliary prefix tree  <a href="#ae74702ea82f7bb98eba8ce5cb1ccc98c">More...</a><br/></td></tr>
<tr class="separator:ae74702ea82f7bb98eba8ce5cb1ccc98c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e307f0cefe7489a9586a7e2cf8a9a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMPTree.html#a86e307f0cefe7489a9586a7e2cf8a9a1">findLongestPrefixInChild</a> (<a class="el" href="structPNode.html">PNode</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K &gt; *_pnode, size_t &amp;_childIdx, <a class="el" href="classRMPTree.html#a3dc76d54f334071d8a2bac2422db0159">ip_type</a> &amp;_longPrefix, <a class="el" href="types_8h.html#a34ecedcf03a70dc91e4616212d79267d">uint8</a> &amp;_longLength, <a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a> &amp;_longNexthop)</td></tr>
<tr class="memdesc:a86e307f0cefe7489a9586a7e2cf8a9a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the longest prefix in the child nodes of a pnode  <a href="#a86e307f0cefe7489a9586a7e2cf8a9a1">More...</a><br/></td></tr>
<tr class="separator:a86e307f0cefe7489a9586a7e2cf8a9a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6405ff9f920c55e2e7b7255d6ff7c478"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMPTree.html#a6405ff9f920c55e2e7b7255d6ff7c478">printPNode</a> (const <a class="el" href="classRMPTree.html#ac37da419a61106e5996632fc83670959">pnode_type</a> *_pnode) const </td></tr>
<tr class="memdesc:a6405ff9f920c55e2e7b7255d6ff7c478"><td class="mdescLeft">&#160;</td><td class="mdescRight">print a primary node  <a href="#a6405ff9f920c55e2e7b7255d6ff7c478">More...</a><br/></td></tr>
<tr class="separator:a6405ff9f920c55e2e7b7255d6ff7c478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227f397d708cf164e3837434778cd7ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMPTree.html#a227f397d708cf164e3837434778cd7ff">scatterToPipeline</a> (int _pipestyle, int _stagenum=H2)</td></tr>
<tr class="memdesc:a227f397d708cf164e3837434778cd7ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter.  <a href="#a227f397d708cf164e3837434778cd7ff">More...</a><br/></td></tr>
<tr class="separator:a227f397d708cf164e3837434778cd7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e278a265a901f31eaabb0a5b94f640"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMPTree.html#a02e278a265a901f31eaabb0a5b94f640">lin</a> (int _stagenum)</td></tr>
<tr class="memdesc:a02e278a265a901f31eaabb0a5b94f640"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter nodes in a linear pipe line.  <a href="#a02e278a265a901f31eaabb0a5b94f640">More...</a><br/></td></tr>
<tr class="separator:a02e278a265a901f31eaabb0a5b94f640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b336010d7aec91920a578b0e830ac9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMPTree.html#ac6b336010d7aec91920a578b0e830ac9">ran</a> (int _stagenum)</td></tr>
<tr class="memdesc:ac6b336010d7aec91920a578b0e830ac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter nodes in a random pipe line.  <a href="#ac6b336010d7aec91920a578b0e830ac9">More...</a><br/></td></tr>
<tr class="separator:ac6b336010d7aec91920a578b0e830ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d3f0f184f191935ddec8a5af90ba07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMPTree.html#a37d3f0f184f191935ddec8a5af90ba07">cir</a> (int _stagenum)</td></tr>
<tr class="memdesc:a37d3f0f184f191935ddec8a5af90ba07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter in a circular pipeline.  <a href="#a37d3f0f184f191935ddec8a5af90ba07">More...</a><br/></td></tr>
<tr class="separator:a37d3f0f184f191935ddec8a5af90ba07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea5eb8ddc2ef237b197ea9712272692e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMPTree.html#aea5eb8ddc2ef237b197ea9712272692e">update</a> (const std::string &amp;_fn, int _stagenum=<a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>-U+1)</td></tr>
<tr class="memdesc:aea5eb8ddc2ef237b197ea9712272692e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the index.  <a href="#aea5eb8ddc2ef237b197ea9712272692e">More...</a><br/></td></tr>
<tr class="separator:aea5eb8ddc2ef237b197ea9712272692e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21826215602a4748acd707461a40c297"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMPTree.html#a21826215602a4748acd707461a40c297">ins</a> (const <a class="el" href="classRMPTree.html#a3dc76d54f334071d8a2bac2422db0159">ip_type</a> &amp;_prefix, const <a class="el" href="types_8h.html#a34ecedcf03a70dc91e4616212d79267d">uint8</a> &amp;_length, const <a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a> &amp;_nexthop, std::default_random_engine &amp;_generator_p, std::uniform_int_distribution&lt; int &gt; &amp;_distribution_p, std::default_random_engine &amp;_generator_s, std::uniform_int_distribution&lt; int &gt; &amp;_distribution_s)</td></tr>
<tr class="memdesc:a21826215602a4748acd707461a40c297"><td class="mdescLeft">&#160;</td><td class="mdescRight">for update, insert into index  <a href="#a21826215602a4748acd707461a40c297">More...</a><br/></td></tr>
<tr class="separator:a21826215602a4748acd707461a40c297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa588b3479961066f6f9295f01e2b953e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMPTree.html#aa588b3479961066f6f9295f01e2b953e">ins</a> (const <a class="el" href="classRMPTree.html#a3dc76d54f334071d8a2bac2422db0159">ip_type</a> &amp;_prefix, const <a class="el" href="types_8h.html#a34ecedcf03a70dc91e4616212d79267d">uint8</a> &amp;_length, const <a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a> &amp;_nexthop, <a class="el" href="classRMPTree.html#ac37da419a61106e5996632fc83670959">pnode_type</a> *&amp;_pnode, const int _level, const <a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a> _treeIdx, std::default_random_engine &amp;_generator_p, std::uniform_int_distribution&lt; int &gt; &amp;_distribution_p, std::default_random_engine &amp;_generator_s, std::uniform_int_distribution&lt; int &gt; &amp;_distribution_s)</td></tr>
<tr class="memdesc:aa588b3479961066f6f9295f01e2b953e"><td class="mdescLeft">&#160;</td><td class="mdescRight">for update, insert into MPT forest  <a href="#aa588b3479961066f6f9295f01e2b953e">More...</a><br/></td></tr>
<tr class="separator:aa588b3479961066f6f9295f01e2b953e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e29ac6b9235a7a82fe7461ce752bc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMPTree.html#a78e29ac6b9235a7a82fe7461ce752bc2">ins</a> (const <a class="el" href="classRMPTree.html#a3dc76d54f334071d8a2bac2422db0159">ip_type</a> &amp;_prefix, const <a class="el" href="types_8h.html#a34ecedcf03a70dc91e4616212d79267d">uint8</a> &amp;_length, const <a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a> &amp;_nexthop, <a class="el" href="classRMPTree.html#ade23f0b765f589613fe10d6cbab738e2">snode_type</a> *&amp;_snode, const int _sLevel, const int _pLevel, const <a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a> _treeIdx, std::default_random_engine &amp;_generator_s, std::uniform_int_distribution&lt; int &gt; &amp;_distribution_s)</td></tr>
<tr class="memdesc:a78e29ac6b9235a7a82fe7461ce752bc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">for update, insert into the auxiliary tree.  <a href="#a78e29ac6b9235a7a82fe7461ce752bc2">More...</a><br/></td></tr>
<tr class="separator:a78e29ac6b9235a7a82fe7461ce752bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab37d3f74dc84185d2cc7aedb417f578"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMPTree.html#aab37d3f74dc84185d2cc7aedb417f578">reportNodeNumInStage</a> (int _stagenum)</td></tr>
<tr class="memdesc:aab37d3f74dc84185d2cc7aedb417f578"><td class="mdescLeft">&#160;</td><td class="mdescRight">report number of nodes in each stage  <a href="#aab37d3f74dc84185d2cc7aedb417f578">More...</a><br/></td></tr>
<tr class="separator:aab37d3f74dc84185d2cc7aedb417f578"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a3dc76d54f334071d8a2bac2422db0159"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="types_8h.html#structchoose__ip__type">choose_ip_type</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a> &gt;<br class="typebreak"/>
::<a class="el" href="classRMPTree.html#a3dc76d54f334071d8a2bac2422db0159">ip_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMPTree.html#a3dc76d54f334071d8a2bac2422db0159">ip_type</a></td></tr>
<tr class="separator:a3dc76d54f334071d8a2bac2422db0159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac37da419a61106e5996632fc83670959"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structPNode.html">PNode</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMPTree.html#ac37da419a61106e5996632fc83670959">pnode_type</a></td></tr>
<tr class="memdesc:ac37da419a61106e5996632fc83670959"><td class="mdescLeft">&#160;</td><td class="mdescRight">primary node type  <a href="#ac37da419a61106e5996632fc83670959">More...</a><br/></td></tr>
<tr class="separator:ac37da419a61106e5996632fc83670959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade23f0b765f589613fe10d6cbab738e2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structSNode.html">SNode</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMPTree.html#ade23f0b765f589613fe10d6cbab738e2">snode_type</a></td></tr>
<tr class="memdesc:ade23f0b765f589613fe10d6cbab738e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">secondary node type  <a href="#ade23f0b765f589613fe10d6cbab738e2">More...</a><br/></td></tr>
<tr class="separator:ade23f0b765f589613fe10d6cbab738e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a4241c1689e08498084c51399549ae6b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRMPTree.html#ac37da419a61106e5996632fc83670959">pnode_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMPTree.html#a4241c1689e08498084c51399549ae6b7">mRootTable</a> [V]</td></tr>
<tr class="memdesc:a4241c1689e08498084c51399549ae6b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointers to a forest of multi-prefix tree  <a href="#a4241c1689e08498084c51399549ae6b7">More...</a><br/></td></tr>
<tr class="separator:a4241c1689e08498084c51399549ae6b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80594c79c981b7599d05b39c8701fbb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMPTree.html#a80594c79c981b7599d05b39c8701fbb8">mLocalLevelPNodeNum</a> [V][H1]</td></tr>
<tr class="memdesc:a80594c79c981b7599d05b39c8701fbb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of pnodes at each level in all MPT  <a href="#a80594c79c981b7599d05b39c8701fbb8">More...</a><br/></td></tr>
<tr class="separator:a80594c79c981b7599d05b39c8701fbb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02dd259c17645662ea922afa6aa5959a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMPTree.html#a02dd259c17645662ea922afa6aa5959a">mLocalLevelSNodeNum</a> [V][H2]</td></tr>
<tr class="memdesc:a02dd259c17645662ea922afa6aa5959a"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of snodes at each level in all MPT  <a href="#a02dd259c17645662ea922afa6aa5959a">More...</a><br/></td></tr>
<tr class="separator:a02dd259c17645662ea922afa6aa5959a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a155ea8b9b340e1e108105062cfb2aa75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMPTree.html#a155ea8b9b340e1e108105062cfb2aa75">mLocalPNodeNum</a> [V]</td></tr>
<tr class="memdesc:a155ea8b9b340e1e108105062cfb2aa75"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of pnodes in each MPT  <a href="#a155ea8b9b340e1e108105062cfb2aa75">More...</a><br/></td></tr>
<tr class="separator:a155ea8b9b340e1e108105062cfb2aa75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5662a149c9af51f1d0d470ee9b700a61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMPTree.html#a5662a149c9af51f1d0d470ee9b700a61">mLocalSNodeNum</a> [V]</td></tr>
<tr class="memdesc:a5662a149c9af51f1d0d470ee9b700a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of snodes in each MPT  <a href="#a5662a149c9af51f1d0d470ee9b700a61">More...</a><br/></td></tr>
<tr class="separator:a5662a149c9af51f1d0d470ee9b700a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bfe436635f93a065affd03637d6b361"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMPTree.html#a5bfe436635f93a065affd03637d6b361">mGlobalLevelPNodeNum</a> [H1]</td></tr>
<tr class="memdesc:a5bfe436635f93a065affd03637d6b361"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of pnodes at each level  <a href="#a5bfe436635f93a065affd03637d6b361">More...</a><br/></td></tr>
<tr class="separator:a5bfe436635f93a065affd03637d6b361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2435f801f07587babed1853cdb04b078"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMPTree.html#a2435f801f07587babed1853cdb04b078">mGlobalLevelSNodeNum</a> [H2]</td></tr>
<tr class="memdesc:a2435f801f07587babed1853cdb04b078"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of snodes at each level  <a href="#a2435f801f07587babed1853cdb04b078">More...</a><br/></td></tr>
<tr class="separator:a2435f801f07587babed1853cdb04b078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583509c36d3ec16fe35ca64ae7d71977"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMPTree.html#a583509c36d3ec16fe35ca64ae7d71977">mTotalPNodeNum</a></td></tr>
<tr class="memdesc:a583509c36d3ec16fe35ca64ae7d71977"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of pnodes  <a href="#a583509c36d3ec16fe35ca64ae7d71977">More...</a><br/></td></tr>
<tr class="separator:a583509c36d3ec16fe35ca64ae7d71977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7293f2b7c8212daaccc3d014a9ca089"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMPTree.html#af7293f2b7c8212daaccc3d014a9ca089">mTotalSNodeNum</a></td></tr>
<tr class="memdesc:af7293f2b7c8212daaccc3d014a9ca089"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of snodes  <a href="#af7293f2b7c8212daaccc3d014a9ca089">More...</a><br/></td></tr>
<tr class="separator:af7293f2b7c8212daaccc3d014a9ca089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94614dd338215403c0e46d8f3bed5e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structFastTable.html">FastTable</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, U-1 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMPTree.html#ad94614dd338215403c0e46d8f3bed5e1">ft</a></td></tr>
<tr class="memdesc:ad94614dd338215403c0e46d8f3bed5e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to the fast lookup table  <a href="#ad94614dd338215403c0e46d8f3bed5e1">More...</a><br/></td></tr>
<tr class="separator:ad94614dd338215403c0e46d8f3bed5e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int W, int K, int U, size_t MP = 2 * K + 1, size_t MC = static_cast&lt;size_t&gt;(pow(2, K)), size_t V = static_cast&lt;size_t&gt;(pow(2, U)), int H1 = (W - U + 1) / K + (((W - U + 1) % K != 0) ? 1 : 0), int H2 = H1 + K&gt;<br/>
class RMPTree&lt; W, K, U, MP, MC, V, H1, H2 &gt;</h3>

<p>Build and update the index. </p>
<p>Prefixes shorter than U bits are stored in a fast lookup table. Prefixes not shorter than U bits are stored in the PT forest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">W</td><td>32 or 128 for IPv4 or IPv6, respectively. </td></tr>
    <tr><td class="paramname">K</td><td>Stride of MPT. </td></tr>
    <tr><td class="paramname">MP</td><td>Max number of prefixes tored in a primary node (2 * K + 1). </td></tr>
    <tr><td class="paramname">MC</td><td>Max number of child pointers stored in a primary node (pow(2, K). </td></tr>
    <tr><td class="paramname">U</td><td>Threshold for classifying shorter and longer prefixes. </td></tr>
    <tr><td class="paramname">V</td><td>Number of prefix trees at large. </td></tr>
    <tr><td class="paramname">H1</td><td>Max level of a primary node. </td></tr>
    <tr><td class="paramname">H2</td><td>Max level of a secondary node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The maximum height of MPT is H1 = (W - U + 1) / K. The maximum height of PT is H2 = H1 + K, where the root node of PT is pointed to by a primary node located at the highest level of MPT. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a3dc76d54f334071d8a2bac2422db0159"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int W, int K, int U, size_t MP = 2 * K + 1, size_t MC = static_cast&lt;size_t&gt;(pow(2, K)), size_t V = static_cast&lt;size_t&gt;(pow(2, U)), int H1 = (W - U + 1) / K + (((W - U + 1) % K != 0) ? 1 : 0), int H2 = H1 + K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="types_8h.html#structchoose__ip__type">choose_ip_type</a>&lt;<a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>&gt;::<a class="el" href="classRMPTree.html#a3dc76d54f334071d8a2bac2422db0159">ip_type</a> <a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt;::<a class="el" href="classRMPTree.html#a3dc76d54f334071d8a2bac2422db0159">ip_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac37da419a61106e5996632fc83670959"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int W, int K, int U, size_t MP = 2 * K + 1, size_t MC = static_cast&lt;size_t&gt;(pow(2, K)), size_t V = static_cast&lt;size_t&gt;(pow(2, U)), int H1 = (W - U + 1) / K + (((W - U + 1) % K != 0) ? 1 : 0), int H2 = H1 + K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structPNode.html">PNode</a>&lt;<a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K&gt; <a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt;::<a class="el" href="classRMPTree.html#ac37da419a61106e5996632fc83670959">pnode_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>primary node type </p>

</div>
</div>
<a class="anchor" id="ade23f0b765f589613fe10d6cbab738e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int W, int K, int U, size_t MP = 2 * K + 1, size_t MC = static_cast&lt;size_t&gt;(pow(2, K)), size_t V = static_cast&lt;size_t&gt;(pow(2, U)), int H1 = (W - U + 1) / K + (((W - U + 1) % K != 0) ? 1 : 0), int H2 = H1 + K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structSNode.html">SNode</a>&lt;<a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>&gt; <a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt;::<a class="el" href="classRMPTree.html#ade23f0b765f589613fe10d6cbab738e2">snode_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>secondary node type </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aa40e0de7051ee571a9d89cd9106e0c62"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int W, int K, int U, size_t MP = 2 * K + 1, size_t MC = static_cast&lt;size_t&gt;(pow(2, K)), size_t V = static_cast&lt;size_t&gt;(pow(2, U)), int H1 = (W - U + 1) / K + (((W - U + 1) % K != 0) ? 1 : 0), int H2 = H1 + K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt;::<a class="el" href="classRMPTree.html">RMPTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>default ctor </p>

</div>
</div>
<a class="anchor" id="a77c366d17bf6c7082188d45b0a9e967a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int W, int K, int U, size_t MP = 2 * K + 1, size_t MC = static_cast&lt;size_t&gt;(pow(2, K)), size_t V = static_cast&lt;size_t&gt;(pow(2, U)), int H1 = (W - U + 1) / K + (((W - U + 1) % K != 0) ? 1 : 0), int H2 = H1 + K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt;::<a class="el" href="classRMPTree.html">RMPTree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>_mpt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>disable copy-ctor </p>

</div>
</div>
<a class="anchor" id="ac23a18d501f8c430a9c313e5a11f5017"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int W, int K, int U, size_t MP = 2 * K + 1, size_t MC = static_cast&lt;size_t&gt;(pow(2, K)), size_t V = static_cast&lt;size_t&gt;(pow(2, U)), int H1 = (W - U + 1) / K + (((W - U + 1) % K != 0) ? 1 : 0), int H2 = H1 + K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt;::~<a class="el" href="classRMPTree.html">RMPTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>dtor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a2a178a47b5eb15869548e79cc13dee8f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int W, int K, int U, size_t MP = 2 * K + 1, size_t MC = static_cast&lt;size_t&gt;(pow(2, K)), size_t V = static_cast&lt;size_t&gt;(pow(2, U)), int H1 = (W - U + 1) / K + (((W - U + 1) % K != 0) ? 1 : 0), int H2 = H1 + K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt;::build </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>_fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build the index. </p>

</div>
</div>
<a class="anchor" id="a37d3f0f184f191935ddec8a5af90ba07"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int W, int K, int U, size_t MP = 2 * K + 1, size_t MC = static_cast&lt;size_t&gt;(pow(2, K)), size_t V = static_cast&lt;size_t&gt;(pow(2, U)), int H1 = (W - U + 1) / K + (((W - U + 1) % K != 0) ? 1 : 0), int H2 = H1 + K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt;::cir </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_stagenum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter in a circular pipeline. </p>
<dl class="section note"><dt>Note</dt><dd>abandon </dd></dl>

</div>
</div>
<a class="anchor" id="acdc7500f870bdf78aee90553dff1fb83"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int W, int K, int U, size_t MP = 2 * K + 1, size_t MC = static_cast&lt;size_t&gt;(pow(2, K)), size_t V = static_cast&lt;size_t&gt;(pow(2, U)), int H1 = (W - U + 1) / K + (((W - U + 1) % K != 0) ? 1 : 0), int H2 = H1 + K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>clear </p>

</div>
</div>
<a class="anchor" id="ad48e9bf6f019b2ae704f61a885c96cd7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int W, int K, int U, size_t MP = 2 * K + 1, size_t MC = static_cast&lt;size_t&gt;(pow(2, K)), size_t V = static_cast&lt;size_t&gt;(pow(2, U)), int H1 = (W - U + 1) / K + (((W - U + 1) % K != 0) ? 1 : 0), int H2 = H1 + K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt;::del </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRMPTree.html#a3dc76d54f334071d8a2bac2422db0159">ip_type</a> &amp;&#160;</td>
          <td class="paramname"><em>_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a34ecedcf03a70dc91e4616212d79267d">uint8</a> &amp;&#160;</td>
          <td class="paramname"><em>_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete a prefix from the index. </p>
<p>A short prefix (&lt; U bits) is deleted from the fast lookup table if exists. A long prefix (&gt;=U bits) is deleted from the forest of multi-prefix tree. </p>

</div>
</div>
<a class="anchor" id="a4b15911964ac9d5312248c5c13f33077"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int W, int K, int U, size_t MP = 2 * K + 1, size_t MC = static_cast&lt;size_t&gt;(pow(2, K)), size_t V = static_cast&lt;size_t&gt;(pow(2, U)), int H1 = (W - U + 1) / K + (((W - U + 1) % K != 0) ? 1 : 0), int H2 = H1 + K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt;::del </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRMPTree.html#a3dc76d54f334071d8a2bac2422db0159">ip_type</a> &amp;&#160;</td>
          <td class="paramname"><em>_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a34ecedcf03a70dc91e4616212d79267d">uint8</a> &amp;&#160;</td>
          <td class="paramname"><em>_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPNode.html">PNode</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K &gt; *&amp;&#160;</td>
          <td class="paramname"><em>_pnode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a>&#160;</td>
          <td class="paramname"><em>_treeIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete a prefix in the index. </p>
<p>Given a prefix P to be deleted from the index and a primary node P at level L: (1) if len(P) &lt; U + K * (L + 1), then try to find the prefix in the auxiliary tree. Delete it if exists. (2) otherwise, try to find the prefix in the current primary node. If current node contains prefix, then remove the prefix following one of two cases: (2-1): if current node is an external node, then directly remove the prefix in the node. (2-2): if currentnode is an internal node, then remove the prefix in the node and fetch the longest prefix in the child nodes to fill up current node again. Then recursively delete the prefix fetched from the child node. </p>

</div>
</div>
<a class="anchor" id="ae74702ea82f7bb98eba8ce5cb1ccc98c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int W, int K, int U, size_t MP = 2 * K + 1, size_t MC = static_cast&lt;size_t&gt;(pow(2, K)), size_t V = static_cast&lt;size_t&gt;(pow(2, U)), int H1 = (W - U + 1) / K + (((W - U + 1) % K != 0) ? 1 : 0), int H2 = H1 + K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt;::del </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRMPTree.html#a3dc76d54f334071d8a2bac2422db0159">ip_type</a> &amp;&#160;</td>
          <td class="paramname"><em>_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a34ecedcf03a70dc91e4616212d79267d">uint8</a> &amp;&#160;</td>
          <td class="paramname"><em>_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRMPTree.html#ade23f0b765f589613fe10d6cbab738e2">snode_type</a> *&amp;&#160;</td>
          <td class="paramname"><em>_snode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>_sLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>_pLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a>&#160;</td>
          <td class="paramname"><em>_treeIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>delete a prefix in an auxiliary prefix tree </p>

</div>
</div>
<a class="anchor" id="abf994ca8e073378dc4a643b1d9c1cfc7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int W, int K, int U, size_t MP = 2 * K + 1, size_t MC = static_cast&lt;size_t&gt;(pow(2, K)), size_t V = static_cast&lt;size_t&gt;(pow(2, U)), int H1 = (W - U + 1) / K + (((W - U + 1) % K != 0) ? 1 : 0), int H2 = H1 + K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt;::deletePrefixInPNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPNode.html">PNode</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K &gt; *&#160;</td>
          <td class="paramname"><em>_pnode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>_pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>delete a prefix at certain position from a primary node </p>

</div>
</div>
<a class="anchor" id="ac59486bc75a65d7ee31e1d54cd64162e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int W, int K, int U, size_t MP = 2 * K + 1, size_t MC = static_cast&lt;size_t&gt;(pow(2, K)), size_t V = static_cast&lt;size_t&gt;(pow(2, U)), int H1 = (W - U + 1) / K + (((W - U + 1) % K != 0) ? 1 : 0), int H2 = H1 + K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt;::destroy </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>destroy a multi-prefix tree </p>

</div>
</div>
<a class="anchor" id="a86e307f0cefe7489a9586a7e2cf8a9a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int W, int K, int U, size_t MP = 2 * K + 1, size_t MC = static_cast&lt;size_t&gt;(pow(2, K)), size_t V = static_cast&lt;size_t&gt;(pow(2, U)), int H1 = (W - U + 1) / K + (((W - U + 1) % K != 0) ? 1 : 0), int H2 = H1 + K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt;::findLongestPrefixInChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPNode.html">PNode</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K &gt; *&#160;</td>
          <td class="paramname"><em>_pnode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>_childIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRMPTree.html#a3dc76d54f334071d8a2bac2422db0159">ip_type</a> &amp;&#160;</td>
          <td class="paramname"><em>_longPrefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a34ecedcf03a70dc91e4616212d79267d">uint8</a> &amp;&#160;</td>
          <td class="paramname"><em>_longLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a> &amp;&#160;</td>
          <td class="paramname"><em>_longNexthop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find the longest prefix in the child nodes of a pnode </p>
<p>If all the child nodes have no prefixes, then they are external nodes and the longest prefix is in one of the auxiliary prefix tree If at least one child node is an internal node, then the longest prefix can be found in one of the child node. </p>

</div>
</div>
<a class="anchor" id="a49b3605159043ab336af2f31c218cf9c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int W, int K, int U, size_t MP = 2 * K + 1, size_t MC = static_cast&lt;size_t&gt;(pow(2, K)), size_t V = static_cast&lt;size_t&gt;(pow(2, U)), int H1 = (W - U + 1) / K + (((W - U + 1) % K != 0) ? 1 : 0), int H2 = H1 + K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt;::findPrefixInPNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRMPTree.html#ac37da419a61106e5996632fc83670959">pnode_type</a> *&#160;</td>
          <td class="paramname"><em>_pnode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRMPTree.html#a3dc76d54f334071d8a2bac2422db0159">ip_type</a> &amp;&#160;</td>
          <td class="paramname"><em>_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a34ecedcf03a70dc91e4616212d79267d">uint8</a> &amp;&#160;</td>
          <td class="paramname"><em>_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to find a prefix in a primary node. </p>
<dl class="section return"><dt>Returns</dt><dd>position of prefix in the node if any; otherwise, t + 1. </dd></dl>

</div>
</div>
<a class="anchor" id="aeb968111f77661b1e7dc46b2d00bb947"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int W, int K, int U, size_t MP = 2 * K + 1, size_t MC = static_cast&lt;size_t&gt;(pow(2, K)), size_t V = static_cast&lt;size_t&gt;(pow(2, U)), int H1 = (W - U + 1) / K + (((W - U + 1) % K != 0) ? 1 : 0), int H2 = H1 + K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt;::generateTrace </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>_reqFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>_traceFile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>generate lookup trace for simulation </p>

</div>
</div>
<a class="anchor" id="a398eb082ee35f45e8e2e119478c3c7aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int W, int K, int U, size_t MP = 2 * K + 1, size_t MC = static_cast&lt;size_t&gt;(pow(2, K)), size_t V = static_cast&lt;size_t&gt;(pow(2, U)), int H1 = (W - U + 1) / K + (((W - U + 1) % K != 0) ? 1 : 0), int H2 = H1 + K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt;::initializeParameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>initialize parameters </p>

</div>
</div>
<a class="anchor" id="a97c8ca5d99c9fce9aeeddae0a2479bb2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int W, int K, int U, size_t MP = 2 * K + 1, size_t MC = static_cast&lt;size_t&gt;(pow(2, K)), size_t V = static_cast&lt;size_t&gt;(pow(2, U)), int H1 = (W - U + 1) / K + (((W - U + 1) % K != 0) ? 1 : 0), int H2 = H1 + K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt;::ins </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRMPTree.html#a3dc76d54f334071d8a2bac2422db0159">ip_type</a> &amp;&#160;</td>
          <td class="paramname"><em>_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a34ecedcf03a70dc91e4616212d79267d">uint8</a> &amp;&#160;</td>
          <td class="paramname"><em>_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a> &amp;&#160;</td>
          <td class="paramname"><em>_nexthop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a prefix into the index. </p>

</div>
</div>
<a class="anchor" id="ac02e80665c49225e72e76fd4867e2c30"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int W, int K, int U, size_t MP = 2 * K + 1, size_t MC = static_cast&lt;size_t&gt;(pow(2, K)), size_t V = static_cast&lt;size_t&gt;(pow(2, U)), int H1 = (W - U + 1) / K + (((W - U + 1) % K != 0) ? 1 : 0), int H2 = H1 + K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt;::ins </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRMPTree.html#a3dc76d54f334071d8a2bac2422db0159">ip_type</a> &amp;&#160;</td>
          <td class="paramname"><em>_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a34ecedcf03a70dc91e4616212d79267d">uint8</a> &amp;&#160;</td>
          <td class="paramname"><em>_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a> &amp;&#160;</td>
          <td class="paramname"><em>_nexthop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRMPTree.html#ac37da419a61106e5996632fc83670959">pnode_type</a> *&amp;&#160;</td>
          <td class="paramname"><em>_pnode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a>&#160;</td>
          <td class="paramname"><em>_treeIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a prefix into the MPT forest. </p>

</div>
</div>
<a class="anchor" id="af26712b559e84c21ee0f3d03ee89bf6b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int W, int K, int U, size_t MP = 2 * K + 1, size_t MC = static_cast&lt;size_t&gt;(pow(2, K)), size_t V = static_cast&lt;size_t&gt;(pow(2, U)), int H1 = (W - U + 1) / K + (((W - U + 1) % K != 0) ? 1 : 0), int H2 = H1 + K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt;::ins </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRMPTree.html#a3dc76d54f334071d8a2bac2422db0159">ip_type</a> &amp;&#160;</td>
          <td class="paramname"><em>_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a34ecedcf03a70dc91e4616212d79267d">uint8</a> &amp;&#160;</td>
          <td class="paramname"><em>_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a> &amp;&#160;</td>
          <td class="paramname"><em>_nexthop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRMPTree.html#ade23f0b765f589613fe10d6cbab738e2">snode_type</a> *&amp;&#160;</td>
          <td class="paramname"><em>_snode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>_sLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>_pLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a>&#160;</td>
          <td class="paramname"><em>_treeIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a prefix into the auxiliary tree. </p>

</div>
</div>
<a class="anchor" id="a21826215602a4748acd707461a40c297"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int W, int K, int U, size_t MP = 2 * K + 1, size_t MC = static_cast&lt;size_t&gt;(pow(2, K)), size_t V = static_cast&lt;size_t&gt;(pow(2, U)), int H1 = (W - U + 1) / K + (((W - U + 1) % K != 0) ? 1 : 0), int H2 = H1 + K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt;::ins </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRMPTree.html#a3dc76d54f334071d8a2bac2422db0159">ip_type</a> &amp;&#160;</td>
          <td class="paramname"><em>_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a34ecedcf03a70dc91e4616212d79267d">uint8</a> &amp;&#160;</td>
          <td class="paramname"><em>_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a> &amp;&#160;</td>
          <td class="paramname"><em>_nexthop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::default_random_engine &amp;&#160;</td>
          <td class="paramname"><em>_generator_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uniform_int_distribution&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>_distribution_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::default_random_engine &amp;&#160;</td>
          <td class="paramname"><em>_generator_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uniform_int_distribution&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>_distribution_s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>for update, insert into index </p>

</div>
</div>
<a class="anchor" id="aa588b3479961066f6f9295f01e2b953e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int W, int K, int U, size_t MP = 2 * K + 1, size_t MC = static_cast&lt;size_t&gt;(pow(2, K)), size_t V = static_cast&lt;size_t&gt;(pow(2, U)), int H1 = (W - U + 1) / K + (((W - U + 1) % K != 0) ? 1 : 0), int H2 = H1 + K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt;::ins </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRMPTree.html#a3dc76d54f334071d8a2bac2422db0159">ip_type</a> &amp;&#160;</td>
          <td class="paramname"><em>_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a34ecedcf03a70dc91e4616212d79267d">uint8</a> &amp;&#160;</td>
          <td class="paramname"><em>_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a> &amp;&#160;</td>
          <td class="paramname"><em>_nexthop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRMPTree.html#ac37da419a61106e5996632fc83670959">pnode_type</a> *&amp;&#160;</td>
          <td class="paramname"><em>_pnode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a>&#160;</td>
          <td class="paramname"><em>_treeIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::default_random_engine &amp;&#160;</td>
          <td class="paramname"><em>_generator_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uniform_int_distribution&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>_distribution_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::default_random_engine &amp;&#160;</td>
          <td class="paramname"><em>_generator_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uniform_int_distribution&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>_distribution_s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>for update, insert into MPT forest </p>

</div>
</div>
<a class="anchor" id="a78e29ac6b9235a7a82fe7461ce752bc2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int W, int K, int U, size_t MP = 2 * K + 1, size_t MC = static_cast&lt;size_t&gt;(pow(2, K)), size_t V = static_cast&lt;size_t&gt;(pow(2, U)), int H1 = (W - U + 1) / K + (((W - U + 1) % K != 0) ? 1 : 0), int H2 = H1 + K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt;::ins </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRMPTree.html#a3dc76d54f334071d8a2bac2422db0159">ip_type</a> &amp;&#160;</td>
          <td class="paramname"><em>_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a34ecedcf03a70dc91e4616212d79267d">uint8</a> &amp;&#160;</td>
          <td class="paramname"><em>_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a> &amp;&#160;</td>
          <td class="paramname"><em>_nexthop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRMPTree.html#ade23f0b765f589613fe10d6cbab738e2">snode_type</a> *&amp;&#160;</td>
          <td class="paramname"><em>_snode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>_sLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>_pLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a>&#160;</td>
          <td class="paramname"><em>_treeIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::default_random_engine &amp;&#160;</td>
          <td class="paramname"><em>_generator_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uniform_int_distribution&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>_distribution_s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>for update, insert into the auxiliary tree. </p>

</div>
</div>
<a class="anchor" id="a36ae5c5ba559386a2e318ad1f9d76832"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int W, int K, int U, size_t MP = 2 * K + 1, size_t MC = static_cast&lt;size_t&gt;(pow(2, K)), size_t V = static_cast&lt;size_t&gt;(pow(2, U)), int H1 = (W - U + 1) / K + (((W - U + 1) % K != 0) ? 1 : 0), int H2 = H1 + K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt;::insertPrefixInPNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRMPTree.html#ac37da419a61106e5996632fc83670959">pnode_type</a> *&#160;</td>
          <td class="paramname"><em>_pnode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRMPTree.html#a3dc76d54f334071d8a2bac2422db0159">ip_type</a> &amp;&#160;</td>
          <td class="paramname"><em>_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a34ecedcf03a70dc91e4616212d79267d">uint8</a> &amp;&#160;</td>
          <td class="paramname"><em>_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a> &amp;&#160;</td>
          <td class="paramname"><em>_nexthop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert prefix into a non-full pnode. </p>
<p>Prefixes in the node are sorted in non-decreasing order by their lengths. This variant is maintained during the insertion. </p>
<dl class="section note"><dt>Note</dt><dd>It is assumed that the primary node is not full yet. </dd></dl>

</div>
</div>
<a class="anchor" id="a02e278a265a901f31eaabb0a5b94f640"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int W, int K, int U, size_t MP = 2 * K + 1, size_t MC = static_cast&lt;size_t&gt;(pow(2, K)), size_t V = static_cast&lt;size_t&gt;(pow(2, U)), int H1 = (W - U + 1) / K + (((W - U + 1) % K != 0) ? 1 : 0), int H2 = H1 + K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt;::lin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_stagenum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter nodes in a linear pipe line. </p>
<dl class="section note"><dt>Note</dt><dd>abandon </dd></dl>

</div>
</div>
<a class="anchor" id="ae16ed3a2d18e52997dfaff4870f2372d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int W, int K, int U, size_t MP = 2 * K + 1, size_t MC = static_cast&lt;size_t&gt;(pow(2, K)), size_t V = static_cast&lt;size_t&gt;(pow(2, U)), int H1 = (W - U + 1) / K + (((W - U + 1) % K != 0) ? 1 : 0), int H2 = H1 + K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRMPTree.html">RMPTree</a>&amp; <a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>disable assignment op </p>

</div>
</div>
<a class="anchor" id="a6405ff9f920c55e2e7b7255d6ff7c478"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int W, int K, int U, size_t MP = 2 * K + 1, size_t MC = static_cast&lt;size_t&gt;(pow(2, K)), size_t V = static_cast&lt;size_t&gt;(pow(2, U)), int H1 = (W - U + 1) / K + (((W - U + 1) % K != 0) ? 1 : 0), int H2 = H1 + K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt;::printPNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRMPTree.html#ac37da419a61106e5996632fc83670959">pnode_type</a> *&#160;</td>
          <td class="paramname"><em>_pnode</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>print a primary node </p>

</div>
</div>
<a class="anchor" id="ac6b336010d7aec91920a578b0e830ac9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int W, int K, int U, size_t MP = 2 * K + 1, size_t MC = static_cast&lt;size_t&gt;(pow(2, K)), size_t V = static_cast&lt;size_t&gt;(pow(2, U)), int H1 = (W - U + 1) / K + (((W - U + 1) % K != 0) ? 1 : 0), int H2 = H1 + K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt;::ran </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_stagenum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter nodes in a random pipe line. </p>
<p>Use different generator to produce random number for distributing primary nodes and secondary nodes. </p>

</div>
</div>
<a class="anchor" id="a740480779eca4924a14f512af6e70675"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int W, int K, int U, size_t MP = 2 * K + 1, size_t MC = static_cast&lt;size_t&gt;(pow(2, K)), size_t V = static_cast&lt;size_t&gt;(pow(2, U)), int H1 = (W - U + 1) / K + (((W - U + 1) % K != 0) ? 1 : 0), int H2 = H1 + K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt;::report </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Report the collected information. </p>

</div>
</div>
<a class="anchor" id="aab37d3f74dc84185d2cc7aedb417f578"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int W, int K, int U, size_t MP = 2 * K + 1, size_t MC = static_cast&lt;size_t&gt;(pow(2, K)), size_t V = static_cast&lt;size_t&gt;(pow(2, U)), int H1 = (W - U + 1) / K + (((W - U + 1) % K != 0) ? 1 : 0), int H2 = H1 + K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt;::reportNodeNumInStage </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_stagenum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>report number of nodes in each stage </p>

</div>
</div>
<a class="anchor" id="a227f397d708cf164e3837434778cd7ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int W, int K, int U, size_t MP = 2 * K + 1, size_t MC = static_cast&lt;size_t&gt;(pow(2, K)), size_t V = static_cast&lt;size_t&gt;(pow(2, U)), int H1 = (W - U + 1) / K + (((W - U + 1) % K != 0) ? 1 : 0), int H2 = H1 + K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt;::scatterToPipeline </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_pipestyle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_stagenum</em> = <code>H2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter. </p>
<p>The structure of an MPT is different from other prefix trees. There's no efficient mapping method to distribute nodes in a MPT into a linear/cirular pipeline without no-ops Here, we only consider random pipeline. </p>

</div>
</div>
<a class="anchor" id="aba048ea59e12faeac571ef5895feb55d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int W, int K, int U, size_t MP = 2 * K + 1, size_t MC = static_cast&lt;size_t&gt;(pow(2, K)), size_t V = static_cast&lt;size_t&gt;(pow(2, U)), int H1 = (W - U + 1) / K + (((W - U + 1) % K != 0) ? 1 : 0), int H2 = H1 + K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a> <a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt;::search </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRMPTree.html#a3dc76d54f334071d8a2bac2422db0159">ip_type</a> &amp;&#160;</td>
          <td class="paramname"><em>_ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>_trace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search LPM for the input IP address. </p>

</div>
</div>
<a class="anchor" id="aea5eb8ddc2ef237b197ea9712272692e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int W, int K, int U, size_t MP = 2 * K + 1, size_t MC = static_cast&lt;size_t&gt;(pow(2, K)), size_t V = static_cast&lt;size_t&gt;(pow(2, U)), int H1 = (W - U + 1) / K + (((W - U + 1) % K != 0) ? 1 : 0), int H2 = H1 + K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt;::update </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_stagenum</em> = <code><a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>&#160;-&#160;U&#160;+&#160;1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the index. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ad94614dd338215403c0e46d8f3bed5e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int W, int K, int U, size_t MP = 2 * K + 1, size_t MC = static_cast&lt;size_t&gt;(pow(2, K)), size_t V = static_cast&lt;size_t&gt;(pow(2, U)), int H1 = (W - U + 1) / K + (((W - U + 1) % K != 0) ? 1 : 0), int H2 = H1 + K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structFastTable.html">FastTable</a>&lt;<a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, U - 1&gt;* <a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt;::ft</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>pointer to the fast lookup table </p>

</div>
</div>
<a class="anchor" id="a5bfe436635f93a065affd03637d6b361"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int W, int K, int U, size_t MP = 2 * K + 1, size_t MC = static_cast&lt;size_t&gt;(pow(2, K)), size_t V = static_cast&lt;size_t&gt;(pow(2, U)), int H1 = (W - U + 1) / K + (((W - U + 1) % K != 0) ? 1 : 0), int H2 = H1 + K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a> <a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt;::mGlobalLevelPNodeNum[H1]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>number of pnodes at each level </p>

</div>
</div>
<a class="anchor" id="a2435f801f07587babed1853cdb04b078"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int W, int K, int U, size_t MP = 2 * K + 1, size_t MC = static_cast&lt;size_t&gt;(pow(2, K)), size_t V = static_cast&lt;size_t&gt;(pow(2, U)), int H1 = (W - U + 1) / K + (((W - U + 1) % K != 0) ? 1 : 0), int H2 = H1 + K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a> <a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt;::mGlobalLevelSNodeNum[H2]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>number of snodes at each level </p>

</div>
</div>
<a class="anchor" id="a80594c79c981b7599d05b39c8701fbb8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int W, int K, int U, size_t MP = 2 * K + 1, size_t MC = static_cast&lt;size_t&gt;(pow(2, K)), size_t V = static_cast&lt;size_t&gt;(pow(2, U)), int H1 = (W - U + 1) / K + (((W - U + 1) % K != 0) ? 1 : 0), int H2 = H1 + K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a> <a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt;::mLocalLevelPNodeNum[V][H1]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>number of pnodes at each level in all MPT </p>

</div>
</div>
<a class="anchor" id="a02dd259c17645662ea922afa6aa5959a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int W, int K, int U, size_t MP = 2 * K + 1, size_t MC = static_cast&lt;size_t&gt;(pow(2, K)), size_t V = static_cast&lt;size_t&gt;(pow(2, U)), int H1 = (W - U + 1) / K + (((W - U + 1) % K != 0) ? 1 : 0), int H2 = H1 + K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a> <a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt;::mLocalLevelSNodeNum[V][H2]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>number of snodes at each level in all MPT </p>

</div>
</div>
<a class="anchor" id="a155ea8b9b340e1e108105062cfb2aa75"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int W, int K, int U, size_t MP = 2 * K + 1, size_t MC = static_cast&lt;size_t&gt;(pow(2, K)), size_t V = static_cast&lt;size_t&gt;(pow(2, U)), int H1 = (W - U + 1) / K + (((W - U + 1) % K != 0) ? 1 : 0), int H2 = H1 + K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a> <a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt;::mLocalPNodeNum[V]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>number of pnodes in each MPT </p>

</div>
</div>
<a class="anchor" id="a5662a149c9af51f1d0d470ee9b700a61"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int W, int K, int U, size_t MP = 2 * K + 1, size_t MC = static_cast&lt;size_t&gt;(pow(2, K)), size_t V = static_cast&lt;size_t&gt;(pow(2, U)), int H1 = (W - U + 1) / K + (((W - U + 1) % K != 0) ? 1 : 0), int H2 = H1 + K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a> <a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt;::mLocalSNodeNum[V]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>number of snodes in each MPT </p>

</div>
</div>
<a class="anchor" id="a4241c1689e08498084c51399549ae6b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int W, int K, int U, size_t MP = 2 * K + 1, size_t MC = static_cast&lt;size_t&gt;(pow(2, K)), size_t V = static_cast&lt;size_t&gt;(pow(2, U)), int H1 = (W - U + 1) / K + (((W - U + 1) % K != 0) ? 1 : 0), int H2 = H1 + K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRMPTree.html#ac37da419a61106e5996632fc83670959">pnode_type</a>* <a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt;::mRootTable[V]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>pointers to a forest of multi-prefix tree </p>

</div>
</div>
<a class="anchor" id="a583509c36d3ec16fe35ca64ae7d71977"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int W, int K, int U, size_t MP = 2 * K + 1, size_t MC = static_cast&lt;size_t&gt;(pow(2, K)), size_t V = static_cast&lt;size_t&gt;(pow(2, U)), int H1 = (W - U + 1) / K + (((W - U + 1) % K != 0) ? 1 : 0), int H2 = H1 + K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a> <a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt;::mTotalPNodeNum</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>number of pnodes </p>

</div>
</div>
<a class="anchor" id="af7293f2b7c8212daaccc3d014a9ca089"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int W, int K, int U, size_t MP = 2 * K + 1, size_t MC = static_cast&lt;size_t&gt;(pow(2, K)), size_t V = static_cast&lt;size_t&gt;(pow(2, U)), int H1 = (W - U + 1) / K + (((W - U + 1) % K != 0) ? 1 : 0), int H2 = H1 + K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#abd01e8e67e3d94cab04ecaaf4f85ac1b">uint32</a> <a class="el" href="classRMPTree.html">RMPTree</a>&lt; <a class="el" href="test__u128_8cpp.html#ab21b528bc38899d04d3a7053e52fb797">W</a>, K, U, MP, MC, V, H1, H2 &gt;::mTotalSNodeNum</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>number of snodes </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/chris/lookup/code/src/tree/<a class="el" href="rmptree_8h_source.html">rmptree.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Dec 8 2016 19:22:51 for iplookup by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
